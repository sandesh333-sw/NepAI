name: NepAI CI/CD Pipeline

on:
  push:
    branches: [main]

permissions:
  contents: write

env:
  IMAGE: pulami/nepai
  DEPLOYMENT: nepai-app
  NAMESPACE: nepai

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # JOB 1: TEST (GitHub cloud â€” free runner)
  # Runs on every push before anything else
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  test:
    name: ğŸ§ª Run Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Lint
        run: npm run lint --if-present

      - name: Type check
        run: npm run type-check --if-present

      - name: Run tests
        run: npm test --if-present
        env:
          CI: true

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # JOB 2: VERSION + BUILD + PUSH
  # Runs on your ARM machine after tests pass
  # Bumps version tag, builds Docker image,
  # pushes versioned + latest to Docker Hub
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  build-and-push:
    name: ğŸ³ Build & Push
    needs: test
    runs-on: [self-hosted, Linux, ARM64]
    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true   # always pull all tags

      - name: Bump patch version from latest tag
        id: version
        run: |
          git fetch --tags   # make sure tags are up to date
          LAST=$(git tag --sort=-v:refname | head -n 1)
          if [ -z "$LAST" ]; then
            VERSION="1.0.0"
          else
            IFS='.' read -r major minor patch <<< "${LAST#v}"
            VERSION="$major.$minor.$((patch + 1))"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "â–¶ Next version: v$VERSION"

      - name: Tag commit with new version
        run: |
          git config user.name  "github-actions"
          git config user.email "actions@github.com"
          git tag v${{ steps.version.outputs.version }}
          git push --tags

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build & push image
        run: |
          VERSION=${{ steps.version.outputs.version }}

          docker build \
            --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}" \
            -t ${{ env.IMAGE }}:$VERSION \
            -t ${{ env.IMAGE }}:latest .

          docker push ${{ env.IMAGE }}:$VERSION
          docker push ${{ env.IMAGE }}:latest

          echo "âœ… Pushed ${{ env.IMAGE }}:$VERSION and :latest"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # JOB 3: DEPLOY
  # Runs on your ARM machine after image is pushed
  # Updates K3s deployment with new version
  # Auto-rollbacks if rollout fails in deployment
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy:
    name: ğŸš€ Deploy to K3s
    needs: build-and-push
    runs-on: [self-hosted, Linux, ARM64]

    steps:
      - name: Deploy new version
        env:
          VERSION: ${{ needs.build-and-push.outputs.version }}
        run: |
          echo "â–¶ Deploying ${{ env.IMAGE }}:$VERSION to K3s..."

          kubectl set image deployment/${{ env.DEPLOYMENT }} \
            nepai=${{ env.IMAGE }}:$VERSION \
            -n ${{ env.NAMESPACE }}

          if kubectl rollout status deployment/${{ env.DEPLOYMENT }} \
               -n ${{ env.NAMESPACE }} --timeout=120s; then
            echo "âœ… Deployed successfully: v$VERSION"
          else
            echo "âŒ Rollout failed â€” reverting to previous version"
            kubectl rollout undo deployment/${{ env.DEPLOYMENT }} \
              -n ${{ env.NAMESPACE }}
            exit 1
          fi

      - name: Show pod status
        if: always()
        run: |
          echo "â”€â”€â”€ Pods â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo "â”€â”€â”€ Deployment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          kubectl describe deployment ${{ env.DEPLOYMENT }} \
            -n ${{ env.NAMESPACE }}